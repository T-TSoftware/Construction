"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProjectSupplierStatusNew = exports.updateProjectSupplierStatus = exports.updateProjectSupplier = exports.getProjectSuppliers = exports.createProjectSupplier = void 0;
const data_source_1 = require("../config/data-source");
const ProjectSupplier_1 = require("../entities/ProjectSupplier");
const CompanyProject_1 = require("../entities/CompanyProject");
const generateCode_1 = require("../utils/generateCode");
const QuantityItem_1 = require("../entities/QuantityItem");
const ProjectQuantity_1 = require("../entities/ProjectQuantity");
const ProjectEstimatedCost_1 = require("../entities/ProjectEstimatedCost");
const supplierRepo = data_source_1.AppDataSource.getRepository(ProjectSupplier_1.ProjectSupplier);
const projectRepo = data_source_1.AppDataSource.getRepository(CompanyProject_1.CompanyProject);
const quantityItemRepo = data_source_1.AppDataSource.getRepository(QuantityItem_1.QuantityItem);
const createProjectSupplier = async (data, currentUser, manager = data_source_1.AppDataSource.manager) => {
    const supplierRepo = manager.getRepository(ProjectSupplier_1.ProjectSupplier);
    const projectRepo = manager.getRepository(CompanyProject_1.CompanyProject);
    const quantityItemRepo = manager.getRepository(QuantityItem_1.QuantityItem);
    const projectQuantityRepo = manager.getRepository(ProjectQuantity_1.ProjectQuantity);
    // âœ… Projeyi bul (ÅŸirket filtresiyle)
    const project = await projectRepo.findOneOrFail({
        where: {
            id: data.projectId,
            company: { id: currentUser.companyId },
        },
    });
    // âœ… Quantity Item'Ä± bul (ÅŸirket filtresiyle)
    const quantityItem = await quantityItemRepo.findOneOrFail({
        where: {
            code: data.quantityItemCode.trim().toUpperCase(),
            company: { id: currentUser.companyId },
        },
    });
    // âœ… Project Quantity opsiyonel
    const projectQuantity = data.projectQuantityCode
        ? await projectQuantityRepo.findOneOrFail({
            where: {
                code: data.projectQuantityCode,
                company: { id: currentUser.companyId },
            },
        })
        : null;
    // âœ… Kod Ã¼retimi
    const code = await (0, generateCode_1.generateNextEntityCode)(manager, project.code, data.category, "TED", "ProjectSupplier");
    // âœ… Kalan tutarÄ± hesapla
    const remainingAmount = typeof data.contractAmount === "number" &&
        typeof data.paidAmount === "number"
        ? data.contractAmount - data.paidAmount
        : undefined;
    // âœ… Yeni tedarikÃ§i oluÅŸtur
    const supplier = supplierRepo.create({
        ...data,
        code,
        quantityItem: { id: quantityItem.id },
        projectQuantity: projectQuantity ? { id: projectQuantity.id } : null,
        remainingAmount,
        project: { id: project.id },
        company: { id: currentUser.companyId }, // ðŸ”¥ GEREKLÄ°
        createdBy: { id: currentUser.userId },
        updatedBy: { id: currentUser.userId },
    });
    await supplierRepo.save(supplier);
    // ðŸ”„ EÄŸer AGREED ise EstimatedCost oluÅŸtur
    if (data.status === "AGREED") {
        const estimatedCostRepo = manager.getRepository(ProjectEstimatedCost_1.ProjectEstimatedCost);
        const isAutoGenerated = data.addedFromQuantityYn === "Y";
        const projectQuantityText = projectQuantity
            ? `${projectQuantity.code} - ${quantityItem.name}`
            : "manuel giriÅŸ";
        const estimatedCost = estimatedCostRepo.create({
            project: { id: project.id },
            company: { id: currentUser.companyId },
            unitPrice: supplier.unitPrice ?? 0,
            unit: supplier.unit,
            quantity: supplier.quantity,
            totalCost: supplier.contractAmount,
            sourceType: "SUPPLIER",
            referenceCode: supplier.code,
            category: supplier.category,
            name: isAutoGenerated
                ? `${data.companyName} â€¢ ${projectQuantityText} iÃ§in otomatik tedarik`
                : `${data.companyName} â€¢ manuel tedarik`,
            description: isAutoGenerated
                ? `Metraj (${projectQuantityText}) kalemi iÃ§in tedarikten otomatik oluÅŸturuldu.`
                : `TedarikÃ§i bilgisi elle girildi. Kaynak metraj baÄŸlantÄ±sÄ± yok.`,
            createdBy: { id: currentUser.userId },
            updatedBy: { id: currentUser.userId },
        });
        await estimatedCostRepo.save(estimatedCost);
    }
    return supplier;
};
exports.createProjectSupplier = createProjectSupplier;
const getProjectSuppliers = async (projectId, currentUser) => {
    const suppliers = await supplierRepo.find({
        where: {
            project: { id: projectId, company: { id: currentUser.companyId } },
            company: { id: currentUser.companyId },
        },
        relations: ["createdBy", "updatedBy", "quantityItem"],
        order: { createdatetime: "DESC" },
    });
    return suppliers.map((supplier) => ({
        id: supplier.id,
        code: supplier.code,
        category: supplier.category,
        quantityItemCode: supplier.quantityItem?.code ?? null,
        companyName: supplier.companyName,
        unit: supplier.unit,
        unitPrice: supplier.unitPrice,
        quantity: supplier.quantity,
        contractAmount: supplier.contractAmount,
        paidAmount: supplier.paidAmount,
        remainingAmount: supplier.remainingAmount,
        status: supplier.status,
        description: supplier.description,
        createdBy: supplier.createdBy?.name ?? null,
        updatedBy: supplier.updatedBy?.name ?? null,
        createdatetime: supplier.createdatetime,
        updatedatetime: supplier.updatedatetime,
    }));
};
exports.getProjectSuppliers = getProjectSuppliers;
const updateProjectSupplier = async (projectId, code, data, currentUser, manager = data_source_1.AppDataSource.manager) => {
    const supplierRepo = manager.getRepository(ProjectSupplier_1.ProjectSupplier);
    const estimatedCostRepo = manager.getRepository(ProjectEstimatedCost_1.ProjectEstimatedCost); // âœ… EstimatedCost ekledik
    const supplier = await supplierRepo.findOne({
        where: {
            code,
            project: { id: projectId, company: { id: currentUser.companyId } },
            company: { id: currentUser.companyId },
        },
        relations: ["project", "company", "quantityItem", "projectQuantity"], // âœ… Ek iliÅŸkiler AGREED iÃ§in gerekli
    });
    if (!supplier)
        throw new Error("TedarikÃ§i bulunamadÄ±.");
    // âœ… LOCKED kontrolÃ¼ supplier iÃ§in kaldÄ±rÄ±ldÄ±
    // âœ… Alanlar gÃ¼ncelleniyor
    supplier.companyName = data.companyName ?? supplier.companyName;
    supplier.unit = data.unit ?? supplier.unit;
    supplier.unitPrice = data.unitPrice ?? supplier.unitPrice;
    supplier.quantity = data.quantity ?? supplier.quantity;
    if (Object.prototype.hasOwnProperty.call(data, "contractAmount")) {
        supplier.contractAmount = data.contractAmount;
    }
    if (Object.prototype.hasOwnProperty.call(data, "paidAmount")) {
        supplier.paidAmount = data.paidAmount;
    }
    supplier.status = data.status ?? supplier.status;
    supplier.description = data.description ?? supplier.description;
    // âœ… Kalan tutar yeniden hesaplanÄ±yor
    if (typeof supplier.contractAmount === "number" &&
        typeof supplier.paidAmount === "number") {
        supplier.remainingAmount = supplier.contractAmount - supplier.paidAmount;
    }
    else {
        supplier.remainingAmount = null;
    }
    supplier.updatedBy = { id: currentUser.userId };
    supplier.updatedatetime = new Date();
    const saved = await supplierRepo.save(supplier);
    // âœ… AGREED durumunda EstimatedCost oluÅŸtur
    if (data.status === "AGREED") {
        const existingEstimate = await estimatedCostRepo.findOne({
            where: {
                project: { id: projectId },
                company: { id: currentUser.companyId },
                sourceType: "SUPPLIER",
                referenceCode: supplier.code, // âœ… Sadece aynÄ± referansla bir defa oluÅŸturulsun
            },
        });
        if (!existingEstimate) {
            const isAutoGenerated = supplier.addedFromQuantityYN === "Y"; // âœ… addedFromQuantity kontrolÃ¼
            const projectQuantityText = supplier.projectQuantity?.code && supplier.quantityItem?.name
                ? `${supplier.projectQuantity.code} - ${supplier.quantityItem.name}`
                : "manuel giriÅŸ";
            const estimatedCost = estimatedCostRepo.create({
                project: { id: projectId },
                company: { id: currentUser.companyId },
                unitPrice: supplier.unitPrice ?? 0,
                unit: supplier.unit, // âœ… unit ekledik
                quantity: supplier.quantity ?? 0, // âœ… quantity ekledik
                totalCost: supplier.contractAmount,
                sourceType: "SUPPLIER",
                referenceCode: supplier.code,
                category: supplier.category,
                name: isAutoGenerated
                    ? `${supplier.companyName} â€¢ ${projectQuantityText} iÃ§in otomatik tedarik`
                    : `${supplier.companyName} â€¢ manuel tedarik`,
                description: isAutoGenerated
                    ? `Metraj (${projectQuantityText}) kalemi iÃ§in tedarikten otomatik oluÅŸturuldu.`
                    : `TedarikÃ§i bilgisi elle girildi. Kaynak metraj baÄŸlantÄ±sÄ± yok.`,
                createdBy: { id: currentUser.userId },
                updatedBy: { id: currentUser.userId },
            });
            await estimatedCostRepo.save(estimatedCost);
        }
    }
    return saved;
};
exports.updateProjectSupplier = updateProjectSupplier;
const updateProjectSupplierStatus = async (supplierCode, amountReceived, currentUser, manager) => {
    const supplierRepo = manager.getRepository(ProjectSupplier_1.ProjectSupplier);
    const supplier = await supplierRepo.findOneOrFail({
        where: {
            code: supplierCode,
            company: { id: currentUser.companyId },
        },
    });
    supplier.paidAmount = Number(supplier.paidAmount ?? 0) + amountReceived;
    supplier.remainingAmount = Number(supplier.contractAmount) - supplier.paidAmount;
    supplier.status = supplier.remainingAmount <= 0 ? "PAID" : "PARTIAL";
    //order.updatedatetime = new Date();
    supplier.updatedBy = { id: currentUser.userId };
    return await supplierRepo.save(supplier);
};
exports.updateProjectSupplierStatus = updateProjectSupplierStatus;
const updateProjectSupplierStatusNew = async (supplierCode, amount, currentUser, manager, isReverse = false) => {
    const supplierRepo = manager.getRepository(ProjectSupplier_1.ProjectSupplier);
    const supplier = await supplierRepo.findOneOrFail({
        where: {
            code: supplierCode,
            company: { id: currentUser.companyId },
        },
    });
    const factor = isReverse ? -1 : 1;
    // âœ… increment/decrement ile Ã¶deme gÃ¼ncelle
    await supplierRepo.increment({ id: supplier.id }, "paidAmount", factor * amount);
    // Mevcut gÃ¼ncel supplier'Ä± yeniden al (paidAmount gÃ¼ncellendi)
    const updatedSupplier = await supplierRepo.findOneOrFail({
        where: { id: supplier.id },
    });
    // âœ… remainingAmount ve status hesapla
    const remainingAmount = Number(updatedSupplier.contractAmount) - Number(updatedSupplier.paidAmount);
    const status = remainingAmount <= 0 ? "PAID" : "PARTIAL";
    // GÃ¼ncelleme
    updatedSupplier.remainingAmount = remainingAmount;
    updatedSupplier.status = status;
    updatedSupplier.updatedBy = { id: currentUser.userId };
    updatedSupplier.updatedatetime = new Date();
    // Kaydet
    return await supplierRepo.save(updatedSupplier);
};
exports.updateProjectSupplierStatusNew = updateProjectSupplierStatusNew;
