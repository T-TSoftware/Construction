import { AppDataSource } from "../config/data-source";
import { EntityManager } from "typeorm";
import { ProjectSupplier } from "../entities/ProjectSupplier";
import { CompanyProject } from "../entities/CompanyProject";
import { generateNextEntityCode } from "../utils/generateCode";
import { QuantityItem } from "../entities/QuantityItem";
import { ProjectQuantity } from "../entities/ProjectQuantity";
import { ProjectEstimatedCost } from "../entities/ProjectEstimatedCost";
import { User } from "../entities/User";

const supplierRepo = AppDataSource.getRepository(ProjectSupplier);
const projectRepo = AppDataSource.getRepository(CompanyProject);
const quantityItemRepo = AppDataSource.getRepository(QuantityItem);

export const createProjectSupplier = async (
  data: {
    projectId: string;
    quantityItemCode: string;
    category: string;
    companyName?: string;
    unit: string;
    unitPrice?: number;
    quantity?: number;
    contractAmount?: number;
    paidAmount?: number;
    status: string;
    description?: string;
    projectQuantityCode?: string;
    addedFromQuantityYn: string;
  },
  currentUser: {
    userId: string;
    companyId: string;
  },
  manager: EntityManager = AppDataSource.manager
) => {
  const supplierRepo = manager.getRepository(ProjectSupplier);
  const projectRepo = manager.getRepository(CompanyProject);
  const quantityItemRepo = manager.getRepository(QuantityItem);
  const projectQuantityRepo = manager.getRepository(ProjectQuantity);

  // âœ… Projeyi bul (ÅŸirket filtresiyle)
  const project = await projectRepo.findOneOrFail({
    where: {
      id: data.projectId,
      company: { id: currentUser.companyId },
    },
  });

  // âœ… Quantity Item'Ä± bul (ÅŸirket filtresiyle)
  const quantityItem = await quantityItemRepo.findOneOrFail({
    where: {
      code: data.quantityItemCode.trim().toUpperCase(),
      company: { id: currentUser.companyId },
    },
  });

  // âœ… Project Quantity opsiyonel
  const projectQuantity = data.projectQuantityCode
    ? await projectQuantityRepo.findOneOrFail({
        where: {
          code: data.projectQuantityCode,
          company: { id: currentUser.companyId },
        },
      })
    : null;

  // âœ… Kod Ã¼retimi
  const code = await generateNextEntityCode(
    manager,
    project.code,
    data.category,
    "TED",
    "ProjectSupplier"
  );

  // âœ… Kalan tutarÄ± hesapla
  const remainingAmount =
    typeof data.contractAmount === "number" &&
    typeof data.paidAmount === "number"
      ? data.contractAmount - data.paidAmount
      : undefined;

  // âœ… Yeni tedarikÃ§i oluÅŸtur
  const supplier = supplierRepo.create({
    ...data,
    code,
    quantityItem: { id: quantityItem.id },
    projectQuantity: projectQuantity ? { id: projectQuantity.id } : null,
    remainingAmount,
    project: { id: project.id },
    company: { id: currentUser.companyId }, // ðŸ”¥ GEREKLÄ°
    createdBy: { id: currentUser.userId },
    updatedBy: { id: currentUser.userId },
  });

  await supplierRepo.save(supplier);

  // ðŸ”„ EÄŸer AGREED ise EstimatedCost oluÅŸtur
  if (data.status === "AGREED") {
    const estimatedCostRepo = manager.getRepository(ProjectEstimatedCost);

    const isAutoGenerated = data.addedFromQuantityYn === "Y";

    const projectQuantityText = projectQuantity
      ? `${projectQuantity.code} - ${quantityItem.name}`
      : "manuel giriÅŸ";

    const estimatedCost = estimatedCostRepo.create({
      project: { id: project.id },
      company: { id: currentUser.companyId },
      unitPrice: supplier.unitPrice ?? 0,
      unit:supplier.unit,
      quantity:supplier.quantity,
      totalCost: supplier.contractAmount,
      sourceType: "SUPPLIER",
      referenceCode: supplier.code,
      category: supplier.category,
      name: isAutoGenerated
        ? `${data.companyName} â€¢ ${projectQuantityText} iÃ§in otomatik tedarik`
        : `${data.companyName} â€¢ manuel tedarik`,
      description: isAutoGenerated
        ? `Metraj (${projectQuantityText}) kalemi iÃ§in tedarikten otomatik oluÅŸturuldu.`
        : `TedarikÃ§i bilgisi elle girildi. Kaynak metraj baÄŸlantÄ±sÄ± yok.`,
      createdBy: { id: currentUser.userId },
      updatedBy: { id: currentUser.userId },
    });
    await estimatedCostRepo.save(estimatedCost);
  }

  return supplier;
};

export const getProjectSuppliers = async (
  projectId: string,
  currentUser: { userId: string; companyId: string }
) => {
  const suppliers = await supplierRepo.find({
    where: {
      project: { id: projectId, company: { id: currentUser.companyId } },
      company: { id: currentUser.companyId },
    },
    relations: ["createdBy", "updatedBy", "quantityItem"],
    order: { createdatetime: "DESC" },
  });

  return suppliers.map((supplier) => ({
    id: supplier.id,
    code: supplier.code,
    category: supplier.category,
    quantityItemCode: supplier.quantityItem?.code ?? null,
    companyName: supplier.companyName,
    unit: supplier.unit,
    unitPrice: supplier.unitPrice,
    quantity: supplier.quantity,
    contractAmount: supplier.contractAmount,
    paidAmount: supplier.paidAmount,
    remainingAmount: supplier.remainingAmount,
    status: supplier.status,
    description: supplier.description,
    createdBy: supplier.createdBy?.name ?? null,
    updatedBy: supplier.updatedBy?.name ?? null,
    createdatetime: supplier.createdatetime,
    updatedatetime: supplier.updatedatetime,
  }));
};

export const updateProjectSupplier = async (
  projectId: string,
  code: string,
  data: {
    companyName?: string;
    unit?: string;
    unitPrice?: number;
    quantity?: number;
    contractAmount?: number;
    paidAmount?: number;
    status?: string;
    description?: string;
  },
  currentUser: {
    userId: string;
    companyId: string;
  },
  manager: EntityManager = AppDataSource.manager
) => {
  const supplierRepo = manager.getRepository(ProjectSupplier);
  const estimatedCostRepo = manager.getRepository(ProjectEstimatedCost); // âœ… EstimatedCost ekledik

  const supplier = await supplierRepo.findOne({
    where: {
      code,
      project: { id: projectId, company: { id: currentUser.companyId } },
      company: { id: currentUser.companyId },
    },
    relations: ["project", "company", "quantityItem", "projectQuantity"], // âœ… Ek iliÅŸkiler AGREED iÃ§in gerekli
  });

  if (!supplier) throw new Error("TedarikÃ§i bulunamadÄ±.");

  // âœ… LOCKED kontrolÃ¼ supplier iÃ§in kaldÄ±rÄ±ldÄ±

  // âœ… Alanlar gÃ¼ncelleniyor
  supplier.companyName = data.companyName ?? supplier.companyName;
  supplier.unit = data.unit ?? supplier.unit;
  supplier.unitPrice = data.unitPrice ?? supplier.unitPrice;
  supplier.quantity = data.quantity ?? supplier.quantity;

  if (Object.prototype.hasOwnProperty.call(data, "contractAmount")) {
    supplier.contractAmount = data.contractAmount!;
  }

  if (Object.prototype.hasOwnProperty.call(data, "paidAmount")) {
    supplier.paidAmount = data.paidAmount!;
  }

  supplier.status = data.status ?? supplier.status;
  supplier.description = data.description ?? supplier.description;

  // âœ… Kalan tutar yeniden hesaplanÄ±yor
  if (
    typeof supplier.contractAmount === "number" &&
    typeof supplier.paidAmount === "number"
  ) {
    supplier.remainingAmount = supplier.contractAmount - supplier.paidAmount;
  } else {
    supplier.remainingAmount = null;
  }

  supplier.updatedBy = { id: currentUser.userId } as any;
  supplier.updatedatetime = new Date();

  const saved = await supplierRepo.save(supplier);

  // âœ… AGREED durumunda EstimatedCost oluÅŸtur
  if (data.status === "AGREED") {
    const existingEstimate = await estimatedCostRepo.findOne({
      where: {
        project: { id: projectId },
        company: { id: currentUser.companyId },
        sourceType: "SUPPLIER",
        referenceCode: supplier.code, // âœ… Sadece aynÄ± referansla bir defa oluÅŸturulsun
      },
    });

    if (!existingEstimate) {
      const isAutoGenerated = supplier.addedFromQuantityYN === "Y"; // âœ… addedFromQuantity kontrolÃ¼

      const projectQuantityText =
        supplier.projectQuantity?.code && supplier.quantityItem?.name
          ? `${supplier.projectQuantity.code} - ${supplier.quantityItem.name}`
          : "manuel giriÅŸ";

      const estimatedCost = estimatedCostRepo.create({
        project: { id: projectId },
        company: { id: currentUser.companyId },
        unitPrice: supplier.unitPrice ?? 0,
        unit: supplier.unit, // âœ… unit ekledik
        quantity: supplier.quantity ?? 0, // âœ… quantity ekledik
        totalCost: supplier.contractAmount,
        sourceType: "SUPPLIER",
        referenceCode: supplier.code,
        category: supplier.category,
        name: isAutoGenerated
          ? `${supplier.companyName} â€¢ ${projectQuantityText} iÃ§in otomatik tedarik`
          : `${supplier.companyName} â€¢ manuel tedarik`,
        description: isAutoGenerated
          ? `Metraj (${projectQuantityText}) kalemi iÃ§in tedarikten otomatik oluÅŸturuldu.`
          : `TedarikÃ§i bilgisi elle girildi. Kaynak metraj baÄŸlantÄ±sÄ± yok.`,
        createdBy: { id: currentUser.userId },
        updatedBy: { id: currentUser.userId },
      });

      await estimatedCostRepo.save(estimatedCost);
    }
  }

  return saved;
};

export const updateProjectSupplierStatus = async (
  supplierCode: string,
  amountReceived: number,
  currentUser: { userId: string; companyId: string },
  manager: EntityManager
) => {
  const supplierRepo = manager.getRepository(ProjectSupplier);

  const supplier = await supplierRepo.findOneOrFail({
    where: {
      code: supplierCode,
      company: { id: currentUser.companyId },
    },
  });

  supplier.paidAmount = Number(supplier.paidAmount ?? 0) + amountReceived;
  supplier.remainingAmount = Number(supplier.contractAmount) - supplier.paidAmount;
  supplier.status = supplier.remainingAmount <= 0 ? "PAID" : "PARTIAL";
  //order.updatedatetime = new Date();
  supplier.updatedBy = { id: currentUser.userId } as User;
  

  return await supplierRepo.save(supplier);
};
