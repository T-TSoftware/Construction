import { AppDataSource } from "../config/data-source";
import { EntityManager } from "typeorm";
import { ProjectSupplier } from "../entities/ProjectSupplier";
import { CompanyProject } from "../entities/CompanyProject";
import { generateNextEntityCode } from "../utils/generateCode";
import { QuantityItem } from "../entities/QuantityItem";
import { ProjectQuantity } from "../entities/ProjectQuantity";
import { ProjectEstimatedCost } from "../entities/ProjectEstimatedCost";
import { User } from "../entities/User";
import { sanitizeRules } from "../utils/sanitizeRules";
import { saveRefetchSanitize } from "../utils/persist";
import { sanitizeEntity } from "../utils/sanitize";

const supplierRepo = AppDataSource.getRepository(ProjectSupplier);
const projectRepo = AppDataSource.getRepository(CompanyProject);
const quantityItemRepo = AppDataSource.getRepository(QuantityItem);

export const createProjectSupplier = async (
  data: {
    projectId: string;
    category: string;
    companyName?: string;
    unit: string;
    unitPrice?: number;
    quantity?: number;
    contractAmount?: number;
    //paidAmount?: number;
    status: string;
    description?: string;
    projectQuantityId?: string;
    addedFromQuantityYN: string;
  },
  currentUser: {
    userId: string;
    companyId: string;
  },
  manager: EntityManager = AppDataSource.manager
) => {
  const supplierRepo = manager.getRepository(ProjectSupplier);
  const projectRepo = manager.getRepository(CompanyProject);
  const projectQuantityRepo = manager.getRepository(ProjectQuantity);

  // âœ… Projeyi bul (ÅŸirket filtresiyle)
  const project = await projectRepo.findOneOrFail({
    where: {
      id: data.projectId,
      company: { id: currentUser.companyId },
    },
  });

  // âœ… Project Quantity opsiyonel
  const projectQuantity = data.projectQuantityId
    ? await projectQuantityRepo.findOneOrFail({
        where: {
          id: data.projectQuantityId,
          company: { id: currentUser.companyId },
        },
      })
    : null;

  // âœ… Kod Ã¼retimi
  const code = await generateNextEntityCode(
    manager,
    project.code,
    data.category,
    "TED",
    "ProjectSupplier"
  );

  const normalizedCategory = data.category.trim().toUpperCase();
  const normalizedUnit = data.unit.trim().toUpperCase();

  // âœ… Yeni tedarikÃ§i oluÅŸtur
  const supplier = supplierRepo.create({
    ...data,
    category: normalizedCategory,
    unit: normalizedUnit,
    code,
    projectQuantity: projectQuantity ? { id: projectQuantity.id } : null,
    remainingAmount: data.contractAmount,
    project: { id: project.id },
    company: { id: currentUser.companyId }, // ðŸ”¥ GEREKLÄ°
    createdBy: { id: currentUser.userId },
    updatedBy: { id: currentUser.userId },
  });

  //await supplierRepo.save(supplier);

  // ðŸ”„ EÄŸer AGREED ise EstimatedCost oluÅŸtur
  /*if (data.status === "AGREED") {
    const estimatedCostRepo = manager.getRepository(ProjectEstimatedCost);

    const isAutoGenerated = data.addedFromQuantityYn === "Y";

    const projectQuantityText = projectQuantity
      ? `${projectQuantity.code} - ${quantityItem.name}`
      : "manuel giriÅŸ";

    const estimatedCost = estimatedCostRepo.create({
      project: { id: project.id },
      company: { id: currentUser.companyId },
      unitPrice: supplier.unitPrice ?? 0,
      unit:supplier.unit,
      quantity:supplier.quantity,
      totalCost: supplier.contractAmount,
      sourceType: "SUPPLIER",
      referenceCode: supplier.code,
      category: supplier.category,
      name: isAutoGenerated
        ? `${data.companyName} â€¢ ${projectQuantityText} iÃ§in otomatik tedarik`
        : `${data.companyName} â€¢ manuel tedarik`,
      description: isAutoGenerated
        ? `Metraj (${projectQuantityText}) kalemi iÃ§in tedarikten otomatik oluÅŸturuldu.`
        : `TedarikÃ§i bilgisi elle girildi. Kaynak metraj baÄŸlantÄ±sÄ± yok.`,
      createdBy: { id: currentUser.userId },
      updatedBy: { id: currentUser.userId },
    });
    await estimatedCostRepo.save(estimatedCost);
  }*/

  //return supplier;
  return await saveRefetchSanitize({
      entityName: "ProjectSupplier",
      save: () => supplierRepo.save(supplier),
      refetch: () =>
        supplierRepo.findOneOrFail({
          where: { id: supplier.id, company: { id: currentUser.companyId } },
          relations: [
            "project",
            "company",
            "projectQuantity",
            "createdBy",
            "updatedBy",
          ],
        }),
      rules: sanitizeRules,
      defaultError: "Tedarik kaydÄ± oluÅŸturulamadÄ±.",
    });
};

export const getProjectSuppliers = async (
  projectId: string,
  currentUser: { userId: string; companyId: string }
) => {
  const suppliers = await supplierRepo.find({
    where: {
      project: { id: projectId, company: { id: currentUser.companyId } },
      company: { id: currentUser.companyId },
    },
    relations: ["createdBy", "updatedBy", "project", "projectQuantity"],
    order: { createdatetime: "DESC" },
  });

  //return suppliers;
  return sanitizeEntity(suppliers, "ProjectSupplier", sanitizeRules);
};

export const getProjectSupplierById = async (
  id: string,
  currentUser: { userId: string; companyId: string }
) => {
  const supplier = await supplierRepo.findOne({
    where: {
      id,
      company: { id: currentUser.companyId },
    },
    relations: ["createdBy", "updatedBy", "project", "projectQuantity"],
  });

  //return supplier;
  return sanitizeEntity(supplier, "ProjectSupplier", sanitizeRules);
};

export const updateProjectSupplier = async (
  id: string,
  data: {
    companyName?: string;
    category?: string;
    unit?: string;
    unitPrice?: number;
    quantity?: number;
    contractAmount?: number;
    paidAmount?: number;
    status?: string;
    description?: string;
  },
  currentUser: {
    userId: string;
    companyId: string;
  },
  manager: EntityManager = AppDataSource.manager
) => {
  const supplierRepo = manager.getRepository(ProjectSupplier);
  const estimatedCostRepo = manager.getRepository(ProjectEstimatedCost); // âœ… EstimatedCost ekledik

  const supplier = await supplierRepo.findOne({
    where: {
      id,
      company: { id: currentUser.companyId },
    },
    relations: ["project", "company", "projectQuantity"], // âœ… Ek iliÅŸkiler AGREED iÃ§in gerekli
  });

  if (!supplier) throw new Error("TedarikÃ§i bulunamadÄ±.");

  // âœ… LOCKED kontrolÃ¼ supplier iÃ§in kaldÄ±rÄ±ldÄ±

  // âœ… Alanlar gÃ¼ncelleniyor
  supplier.companyName = data.companyName ?? supplier.companyName;
  supplier.category = data.category ?? supplier.category;
  supplier.unit = data.unit ?? supplier.unit;
  supplier.unitPrice = data.unitPrice ?? supplier.unitPrice;
  supplier.quantity = data.quantity ?? supplier.quantity;

  if (Object.prototype.hasOwnProperty.call(data, "contractAmount")) {
    supplier.contractAmount = data.contractAmount!;
    supplier.remainingAmount =
      Number(data.contractAmount ?? 0) - Number(supplier.paidAmount ?? 0);
  }

  supplier.status = data.status ?? supplier.status;
  supplier.description = data.description ?? supplier.description;

  supplier.updatedBy = { id: currentUser.userId } as any;
  supplier.updatedatetime = new Date();

  //const saved = await supplierRepo.save(supplier);

  // âœ… AGREED durumunda EstimatedCost oluÅŸtur
  /*if (data.status === "AGREED") {
    const existingEstimate = await estimatedCostRepo.findOne({
      where: {
        project: { id: supplier.project.id },
        company: { id: currentUser.companyId },
        sourceType: "SUPPLIER",
        referenceCode: supplier.code, // âœ… Sadece aynÄ± referansla bir defa oluÅŸturulsun
      },
    });

    if (!existingEstimate) {
      const isAutoGenerated = supplier.addedFromQuantityYN === "Y"; // âœ… addedFromQuantity kontrolÃ¼

      const projectQuantityText =
        supplier.projectQuantity?.code && supplier.quantityItem?.name
          ? `${supplier.projectQuantity.code} - ${supplier.quantityItem.name}`
          : "manuel giriÅŸ";

      const estimatedCost = estimatedCostRepo.create({
        project: { id: supplier.project.id },
        company: { id: currentUser.companyId },
        unitPrice: supplier.unitPrice ?? 0,
        unit: supplier.unit, // âœ… unit ekledik
        quantity: supplier.quantity ?? 0, // âœ… quantity ekledik
        totalCost: supplier.contractAmount,
        sourceType: "SUPPLIER",
        referenceCode: supplier.code,
        category: supplier.category,
        name: isAutoGenerated
          ? `${supplier.companyName} â€¢ ${projectQuantityText} iÃ§in otomatik tedarik`
          : `${supplier.companyName} â€¢ manuel tedarik`,
        description: isAutoGenerated
          ? `Metraj (${projectQuantityText}) kalemi iÃ§in tedarikten otomatik oluÅŸturuldu.`
          : `TedarikÃ§i bilgisi elle girildi. Kaynak metraj baÄŸlantÄ±sÄ± yok.`,
        createdBy: { id: currentUser.userId },
        updatedBy: { id: currentUser.userId },
      });

      await estimatedCostRepo.save(estimatedCost);
    }
  }*/

  //return saved;
  return await saveRefetchSanitize({
      entityName: "ProjectSupplier",
      save: () => supplierRepo.save(supplier),
      refetch: () =>
        supplierRepo.findOneOrFail({
          where: { id: supplier.id, company: { id: currentUser.companyId } },
          relations: [
            "project",
            "company",
            "projectQuantity",
            "createdBy",
            "updatedBy",
          ],
        }),
      rules: sanitizeRules,
      defaultError: "Tedarik kaydÄ± oluÅŸturulamadÄ±.",
    });
};

export const updateProjectSupplierStatus = async (
  supplierCode: string,
  amountReceived: number,
  currentUser: { userId: string; companyId: string },
  manager: EntityManager
) => {
  const supplierRepo = manager.getRepository(ProjectSupplier);

  const supplier = await supplierRepo.findOneOrFail({
    where: {
      code: supplierCode,
      company: { id: currentUser.companyId },
    },
  });

  supplier.paidAmount = Number(supplier.paidAmount ?? 0) + amountReceived;
  supplier.remainingAmount =
    Number(supplier.contractAmount) - supplier.paidAmount;
  supplier.status = supplier.remainingAmount <= 0 ? "PAID" : "PARTIAL";
  //order.updatedatetime = new Date();
  supplier.updatedBy = { id: currentUser.userId } as User;

  return await supplierRepo.save(supplier);
};

export const updateProjectSupplierStatusNew = async (
  supplierCode: string,
  amount: number,
  currentUser: { userId: string; companyId: string },
  manager: EntityManager,
  isReverse = false
) => {
  const supplierRepo = manager.getRepository(ProjectSupplier);

  const supplier = await supplierRepo.findOneOrFail({
    where: {
      code: supplierCode,
      company: { id: currentUser.companyId },
    },
  });

  const factor = isReverse ? -1 : 1;

  // âœ… increment/decrement ile Ã¶deme gÃ¼ncelle
  await supplierRepo.increment(
    { id: supplier.id },
    "paidAmount",
    factor * amount
  );

  // Mevcut gÃ¼ncel supplier'Ä± yeniden al (paidAmount gÃ¼ncellendi)
  const updatedSupplier = await supplierRepo.findOneOrFail({
    where: { id: supplier.id },
  });

  // âœ… remainingAmount ve status hesapla
  const remainingAmount =
    Number(updatedSupplier.contractAmount) - Number(updatedSupplier.paidAmount);
  const status = remainingAmount <= 0 ? "PAID" : "PARTIAL";

  // GÃ¼ncelleme
  updatedSupplier.remainingAmount = remainingAmount;
  updatedSupplier.status = status;
  updatedSupplier.updatedBy = { id: currentUser.userId } as User;
  updatedSupplier.updatedatetime = new Date();

  // Kaydet
  return await supplierRepo.save(updatedSupplier);
};
